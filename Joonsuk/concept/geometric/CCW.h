// CCW 알고리즘을 이해하기 위해서는 벡터의 외적을 이해해야 한다.

// 벡터 A, B가 있다고 할때, A와 B의 외적은, 두 벡터에 동시에 수직인 또 다른 벡터 C이다.
// 하지만, 벡터 A와 B가 이루는 부분공간 S에 수직인 벡터는 2개가 존재한다. (아래방향, 위방향)

// 이 2개의 벡터 중에서, 어떠한 벡터로 결정되는지는, 외적의 방향에 의해서 결정된다.
// 이는 오른손 법칙으로 쉽게 알 수 있는데, 벡터간의 곱셈(외적)은 교환법칙이 성립하지 않으므로 A X B와 B X A가 다르다.
// 곱셈의 순서 방향으로 오른손을 감싼 후에, 엄지가 가리키는 방향이 수직 벡터의 방향이 된다.

// 자 이제 CCW로 돌아와서 점 A, B, C가 있다고 하자.
// AB와 BC 벡터가 존재한다고 하면, 두 벡터의 외적은 시계 방향인지, 반시계 방향인지에 따라서 수직벡터의 방향이 갈린다.
// 시계방향이라면 수직벡터의 z값이 -가 나올 것이고,
// 반시계 방향이라면 수직벡터의 z값이 +가 나올 것이다.
// 마지막으로 일직선이라면, 0이 나오게 된다. (참고: https://blog.naver.com/mindo1103/90103361104)

#ifndef CCW_H
#define CCW_H

int CCW(int x1, int x2, int x3, int y1, int y2, int y3){
    // AB 벡터
    // {(x2 - x1) , (y2 - y1)}

    // BC 벡터
    // {(x3 - x2) , (y3 - y2)}

    // AB와 BC의 외적
    // 외적을 구하는 법은 다음과 같다 = det( |1 1 1; a1 a2 a3; b1 b2 b3; | )
    // 즉 (a2b3 - a3b2, a3b1 - a2b3, a1b2 - a2b1)
    // 이때 a3, b3는 모두 0이므로 (z좌표 값)
    int outer_product = (x2 - x1)*(y3 - y2) - (y2 - y1)*(x3 - x2);   
    return outer_product;
}

#endif